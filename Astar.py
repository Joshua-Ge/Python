mazes = [
["#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#"],
["#", "X", " ", " ", "#", " ", "#", " ", " ", " ", "#", " ", "#", " ", "#", "#", " ", " ", " ", " ", "#", "#", " ", "#", " ", "#", " ", " ", " ", "*", "#"],
["#", "#", "#", " ", "#", " ", "#", " ", "#", " ", "#", " ", "#", " ", " ", "#", "#", "#", "#", "#", "#", " ", "#", " ", "#", " ", "#", "#", "#", " ", "#"],
["#", " ", " ", " ", "#", " ", " ", " ", "#", " ", " ", " ", "#", "#", " ", " ", " ", " ", " ", " ", "#", " ", "#", "#", "#", " ", " ", " ", " ", " ", "#"],
["#", " ", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", " ", "#", "#", "#", " ", "#", "#", "#", " ", "#", " ", "#"],
["#", " ", "#", " ", "#", " ", " ", " ", " ", " ", " ", " ", " ", " ", "#", " ", " ", " ", "#", " ", "#", " ", " ", " ", "#", " ", " ", " ", "#", "#", "#"],
["#", " ", "#", " ", "#", "#", "#", "#", "#", "#", "#", "#", "#", " ", "#", "#", "#", " ", "#", " ", "#", "#", "#", "#", "#", " ", "#", " ", " ", " ", "#"],
["#", " ", "#", " ", " ", " ", "#", " ", " ", " ", " ", " ", "#", " ", " ", " ", "#", " ", " ", " ", " ", " ", " ", " ", " ", " ", "#", "#", "#", " ", "#"],
["#", " ", "#", "#", "#", " ", "#", "#", "#", "#", "#", "#", "#", "#", "#", " ", "#", "#", "#", "#", "#", "#", "#", " ", "#", " ", "#", " ", "#", " ", "#"],
["#", " ", "#", " ", "#", " ", " ", " ", " ", " ", " ", "#", " ", " ", "#", " ", " ", " ", "#", " ", " ", " ", "#", " ", "#", " ", "#", " ", "#", " ", "#"],
["#", " ", "#", " ", "#", "#", "#", "#", "#", "#", " ", "#", " ", "#", "#", "#", "#", "#", "#", "#", "#", " ", "#", " ", "#", " ", "#", "#", "#", " ", "#"],
["#", " ", " ", " ", " ", " ", " ", "#", " ", " ", " ", "#", " ", "#", " ", " ", " ", " ", " ", " ", "#", " ", " ", " ", "#", " ", " ", " ", "#", " ", "#"],
["#", "#", "#", "#", " ", "#", " ", "#", " ", "#", "#", "#", " ", "#", "#", "#", "#", "#", "#", " ", "#", "#", " ", "#", "#", "#", "#", " ", "#", "#", "#"],
["#", " ", " ", " ", " ", "#", " ", "#", " ", " ", " ", "#", " ", "#", " ", " ", " ", "#", " ", " ", " ", " ", " ", "#", " ", " ", " ", " ", " ", " ", "#"],
["#", "#", "#", "#", " ", "#", "#", "#", "#", "#", " ", "#", "#", "#", "#", "#", " ", "#", "#", " ", "#", "#", "#", "#", " ", "#", "#", "#", "#", " ", "#"],
["#", " ", " ", "#", " ", " ", " ", " ", "#", " ", " ", " ", " ", " ", "#", " ", " ", " ", " ", " ", "#", " ", " ", "#", " ", "#", " ", " ", "#", " ", "#"],
["#", " ", "#", "#", "#", "#", "#", " ", "#", "#", "#", "#", "#", " ", "#", "#", "#", " ", "#", "#", "#", "#", " ", "#", " ", "#", " ", "#", "#", " ", "#"],
["#", " ", "#", " ", " ", " ", "#", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "#", " ", " ", " ", " ", "#", " ", "#", " ", " ", "#"],
["#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#"]
]


class Maze:
    def __init__(self, maze):
        self.maze = maze
        self.start = self.find_symbol("X")
        self.goal = self.find_symbol("*")
        self.start_x, self.start_y = self.start
        self.goal_x, self.goal_y = self.goal
        self.visited = set()
        self.path = {}
        self.x = self.start_x
        self.y = self.start_y
        self.g = 0
        
    def manhattan(self,x1,y1):
        return abs(x1 - self.goal_x) + abs(y1 - self.goal_y)


    def find_symbol(self, symbol):
        for y, row in enumerate(self.maze):
            for x, cell in enumerate(row):
                if cell == symbol:
                    return (x,y)
        return None
    
    def in_bounds(self,x, y):
        return 0 <= y < len(self.maze) and 0 <= x < len(self.maze[0])

    def a_star(self):
        
        h = self.manhattan(self.start_x, self.start_y)
        moveL = [(h, 0, (self.start_x, self.start_y))]
    
        
        while moveL:
            
            moveL.sort()
            f, g, location = moveL.pop(0)

            x,y = location

            if location == self.goal:
                cx, cy = location
                while (cx,cy) != self.start:
                    self.maze[cy][cx] = "X"
                    cx,cy = self.path[(cx,cy)]
                return True
            
            self.visited.add(location)

            direction = [(1,0),(-1,0),(0,1),(0,-1)]

            for dx, dy in direction:
                nx = x + dx
                ny = y + dy

                if not self.in_bounds(nx,ny):
                    continue

                if self.maze[ny][nx] in (" ", "*") and (nx,ny) not in self.visited:
                    ng = g + 1
                    h = self.manhattan(nx,ny)
                    nf = h + ng 
                    moveL.append((nf,ng,(nx,ny)))
                    self.path[(nx,ny)] = (x,y)
        return False


    def show(self):
        print()
        for i, row in enumerate(self.maze):
            print(*row)
        print()


search = Maze(mazes)
search.show()
search.a_star()
search.show()
